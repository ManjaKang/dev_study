# git

Git은 소프트웨어 개발 및 협업에 사용되는 분산 버전 제어 시스템입니다. 이를 통해 여러 개발자가 동일한 코드베이스에서 동시에 작업하고 시간 경과에 따른 코드 변경 사항을 추적할 수 있습니다. Git은 Linux 커널 개발을 관리하기 위해 2005년에 Linus Torvalds가 만들었습니다.



### git 파일 시스템

Git은 코드베이스의 변경 사항을 관리하는 분산 버전 제어 시스템입니다. 이를 위해 Git은 작업 트리, 인덱스(스테이징 영역이라고도 함) 및 리포지토리의 세 가지 주요 부분으로 구성된 파일 시스템 구조를 사용합니다.

- 작업 트리: 이것은 코드베이스에서 파일을 편집하고 수정하는 디렉토리입니다. 작업 트리에서 파일을 변경하면 Git은 이러한 변경 사항을 감지하고 향후 커밋을 위해 이를 추적합니다. 작업 트리는 작업 디렉터리 또는 체크아웃이라고도 합니다.
- 인덱스(스테이징 영역): 커밋에 대한 변경 사항을 준비할 수 있는 중간 영역입니다. . 변경 사항을 커밋하기 전에 먼저 인덱스에 추가해야 합니다. 이것은 작업 트리에서 인덱스로 변경 사항을 복사하는 `git add` 명령을 사용하여 수행됩니다. 변경 사항이 인덱스에 있으면 커밋할 준비가 된 것입니다.
- 저장소: Git이 코드베이스에 대한 커밋된 모든 변경 사항을 완전한 파일과 함께 저장하는 곳입니다. 모든 변경 내역. 리포지토리는 일반적으로 GitHub 또는 GitLab과 같은 원격 서버에 저장되거나 컴퓨터에 로컬로 저장됩니다. 리포지토리에 대한 변경 사항을 커밋하면 Git은 해당 시점에 코드베이스에 적용된 변경 사항의 스냅샷이 포함된 새 커밋 객체를 생성합니다. 리포지토리의 각 커밋은 고유한 SHA-1 해시로 식별되므로 Git에서 시간 경과에 따른 변경 사항을 추적하고 충돌을 해결할 수 있습니다.



### git 명령어

- `git init`: 디렉터리에서 새 Git 리포지토리를 초기화하여 `.git을 생성합니다. ` Git이 메타데이터를 저장하는 하위 디렉토리입니다.
- `git add`: 인덱스(스테이징 영역이라고도 함)에 변경 사항을 추가하여 준비합니다. 다음 커밋을 위해.
- `git commit`: 변경 사항을 설명하는 메시지와 함께 코드베이스의 새 스냅샷을 생성하여 리포지토리에 변경 사항을 커밋합니다. 
- `git status`: 수행되었지만 아직 인덱스에 추가되지 않은 변경 사항을 포함하여 작업 트리의 현재 상태를 표시합니다. 준비되었으며 커밋할 준비가 된 변경 사항.
- `git diff`: 작업 트리와 인덱스 간의 차이점 또는 색인 및 가장 최근 커밋.
- `git log`: 커밋 메시지, 작성자, 각 커밋의 nd 날짜.
- `git branch`: 저장소의 분기를 나열하거나 새 분기를 생성합니다.
- `git checkout`: 다른 분기로 전환하거나 특정 커밋 또는 파일을 체크아웃합니다.
- `git merge`: 한 분기에서 다른 분기로 변경 사항을 병합하여 두 분기에서 변경된 내용을 결합합니다.
- `git pull`: 원격 리포지토리를 현재 브랜치로 병합합니다.
- `git push`: 로컬 커밋을 원격 리포지토리로 보내고 변경 사항으로 상태를 업데이트합니다. 



### git switch와 git checkout

Git 버전 2.23 이상에서 `git switch` 명령은 분기 간 전환이나 특정 커밋을 체크아웃하기 위한 이전 `git checkout` 명령의 대안으로 도입되었습니다. 두 명령을 사용하여 유사한 결과를 얻을 수 있지만 두 명령 사이에는 몇 가지 주요 차이점이 있습니다.

1. 분기 간 전환: `git switch`는 주로 전환을 위해 설계되었습니다. `git checkout`은 새 분기를 생성하거나 특정 파일을 체크아웃하는 것과 같은 더 넓은 범위의 작업에 사용할 수 있습니다.
2. 단순한 구문 : `git switch`는 `git checkout`보다 구문이 간단하고 더 일관된 매개변수 집합을 사용합니다. 예를 들어 "mybranch"라는 브랜치로 전환하려면 `git switch mybranch` 명령을 사용하고 `git checkout`에서는 `git checkout mybranch`< 명령을 사용합니다. /code>.`
3. 안전성: `git switch`는 브랜치 간 전환 시 `git checkout`보다 더 안전하도록 설계되었습니다. 특히 git switch는 분기 이름을 잘못 입력한 경우 git checkout에서 발생할 수 있는 분기 대신 실수로 파일을 체크아웃하는 것을 방지합니다.`
4. 변경 사항 미리보기: `git switch`를 사용하면 -discard를 사용하여 분기를 전환할 때 작업 트리에 적용될 변경 사항을 미리 볼 수 있습니다. -changes 및 --recurse-submodules 옵션. 이는 변경하기 전에 올바른 분기로 전환하고 있는지 확인하는 데 유용할 수 있습니다.`



### git fetch와 git remote update

`git fetch` 및 `git remote update`는 모두 원격 저장소의 변경 사항으로 로컬 저장소를 업데이트하는 데 사용됩니다. 그러나 두 명령 사이에는 몇 가지 차이점이 있습니다.

`git remote update` 명령은 `git fetch`와 유사하지만 기본 분기뿐만 아니라 모든 원격 추적 분기를 업데이트합니다. 이 명령은 추적 중인 모든 원격 저장소에 대한 원격 추적 분기를 업데이트합니다. `git remote update`와 함께 `--prune` 옵션을 사용하여 원격 저장소에 더 이상 존재하지 않는 원격 추적 분기를 제거할 수도 있습니다.



### git log와 git reflog

`git log`와 `git reflog`는 모두 리포지토리 기록을 검토하는 데 사용되는 Git 명령이지만 다른 용도로 사용됩니다.

`git log`는 각 커밋에 대한 커밋 메시지, 작성자, 날짜 및 고유한 해시 식별자와 같은 정보를 포함하여 저장소의 커밋 기록을 표시하는 데 사용됩니다. 기본적으로 `git log`는 가장 최근 커밋부터 시작하여 시간을 거꾸로 작업하여 리포지토리의 전체 기록을 보여줍니다. 그러나 다양한 옵션과 필터를 사용하여 특정 커밋 범위를 지정하거나 작성자 또는 커밋 메시지로 필터링하는 등 출력을 사용자 지정할 수도 있습니다.

한편 `git reflog`는 브랜치 및 태그와 같은 Git 참조와 숨김 및 재설정 작업과 같은 기타 "reflog 항목"에 대한 변경 로그를 표시하는 데 사용됩니다. reflog는 손실된 커밋, 분기 또는 기타 참조를 복구하는 방법을 제공하며 참조가 실수로 삭제되거나 덮어쓴 상황에서 유용할 수 있습니다. 기본적으로 git reflog는 현재 분기에 대한 변경 로그를 표시하지만 특정 참조에 대한 reflog를 표시하도록 다른 참조를 지정할 수도 있습니다.`



### 추가 git 명령어

1. `git revert`: 이 명령은 이전 커밋을 "되돌리는" 새 커밋을 생성하여 이전 커밋을 취소하는 데 사용됩니다. 이전 커밋에서 변경된 사항. 원래 커밋은 여전히 기록에 보존되지만 변경 사항은 현재 분기에서 제거됩니다. 이는 커밋을 실행 취소하지만 원래 변경 사항을 계속 기록하고 싶을 때 유용합니다.
2. `git reset`: 이 명령은 재설정하는 데 사용됩니다. 현재 분기를 이전 커밋으로, 모든 후속 커밋을 효과적으로 "실행 취소"합니다. `git revert`와 달리 이 명령은 기록에서 커밋을 영구적으로 제거하므로 주의하여 사용하십시오. `git reset`에는 세 가지 다른 모드(소프트, 혼합 및 하드)가 있으며 커밋 기록을 얼마나 많이 제거할지 결정합니다.
3.  `git cherry-pick`: 이 명령은 하나 이상의 기존 커밋의 변경 사항을 현재 분기에 적용하는 데 사용됩니다. 원래 커밋과 동일한 변경 사항을 포함하지만 새로운 커밋 메시지와 해시를 포함하는 새 커밋을 생성합니다. 이는 전체 분기를 병합하지 않고 한 분기에서 다른 분기로 변경 사항을 선택적으로 적용하려는 경우에 유용합니다.



### HEAD

Git에서 `HEAD`는 작업 디렉토리가 기반으로 하는 현재 분기 또는 커밋을 나타냅니다. 기본적으로 작업 중인 현재 분기 또는 커밋을 가리키는 포인터입니다.

새 커밋을 만들면 `HEAD` 포인터가 새 커밋을 가리키도록 업데이트됩니다. 브랜치의 새로운 "팁"이 되는 commit. 마찬가지로 분기를 전환하거나 특정 커밋을 체크아웃하면 `HEAD` 포인터가 업데이트되어 현재 작업 중인 새 분기나 커밋을 반영합니다.

`HEAD~1` 은 현재 HEAD의 한 단계 이전 HEAD를 의미한다.



### git hooks

Git 후크는 작업을 자동화하고 Git 워크플로에서 사용자 지정 워크플로를 적용하는 강력한 방법을 제공합니다. 후크를 사용하면 시간을 절약하고 코드 품질을 개선하는 동시에 팀이 일관된 프로세스와 표준을 따르도록 할 수 있습니다. hooks를 사용하면 다음과 같은 작업을 할 수 있습니다.

- 각 커밋 전에 자동화된 테스트 또는 코드 분석 도구 실행
- 코딩 표준 또는 서식 규칙 적용
- 특정 키워드 또는 형식 요구 사항에 대한 커밋 메시지 확인
- 릴리스 노트 또는 변경 로그 자동 생성
- 자동 빌드 또는 배포 트리거
- 타사와 통합 도구 또는 서비스



### .git/info/exclude 와 .gitignore

exclude 는 현재 리포지토리에서 추적하지 않을 파일을 지정하고

gitignore는 모든 git 저장소에서 추적하지 않을 파일을 지정하는 용도이다.



### .git/logs

`.git/ logs` 폴더에는 각 분기에 대한 로그와 병합 및 가져오기와 같은 기타 Git 작업에 대한 로그가 포함되어 있습니다. 각 로그 파일은 관련된 분기 또는 작업의 이름을 따서 명명되며 커밋 및 기타 이벤트의 연대순 목록을 포함합니다.

`.git/logs` 폴더의 로그 파일은 다음과 같습니다. Git에서 리포지토리의 변경 사항을 추적하고 문제 발생 시 손실된 데이터를 복구하는 데 사용됩니다. 그러나 이러한 로그 파일은 데이터 손상 및 기타 문제를 일으킬 수 있으므로 사용자가 직접 편집하거나 수정할 수 없습니다.

Git 리포지토리의 커밋 기록을 보려면 다음을 사용할 수 있습니다. 대신 `git log` 명령을 사용하세요. 이 명령은 작성자, 날짜 및 커밋 메시지와 같은 각 커밋에 대한 정보와 함께 리포지토리의 모든 커밋 목록을 표시합니다. `git log` 명령과 함께 다양한 옵션과 인수를 사용하여 다양한 방식으로 출력을 필터링하고 형식을 지정할 수 있습니다.



### .git/objects

Git 리포지토리에서 변경 사항을 추가, 커밋 또는 푸시할 때 Git은 다음을 나타내는 새 객체를 생성합니다. 변화들. 그런 다음 이러한 객체는 `.git/objects` 폴더에 저장됩니다. 각 개체는 Git에서 개체를 참조하는 데 사용하는 40자 SHA-1 해시로 고유하게 식별됩니다.

`.git/objects` 폴더에는 두 개의 하위 디렉터리가 있습니다. < code>info 및 `pack`. `info` 디렉토리에는 Git이 사용하는 다양한 정보 파일이 포함되어 있고 `pack` 디렉토리에는 압축 및 패킹된 개체가 포함되어 있습니다. 리포지토리의 개체 수가 너무 많아지면 Git은 공간을 절약하기 위해 자동으로 단일 파일로 압축합니다.

Git 리포지토리에서 개체 디렉터리에는 느슨한 개체와 묶인 개체라는 두 가지 유형의 개체 저장 형식이 포함되어 있습니다.

느슨한 개체는 SHA- 개체의 1 해시, 압축된 개체는 팩 디렉터리 아래의 팩 파일에 저장됩니다.

개체 디렉터리 아래의 두 자리 16진수 폴더에는 압축되지 않은 느슨한 개체가 포함되어 있습니다. 각 개체는 SHA-1 해시의 나머지 38자로 이름이 지정된 고유한 파일에 저장됩니다.

반면 팩 폴더에는 바이너리 형식으로 압축 및 저장된 압축된 개체가 포함되어 있습니다. 효율적인 보관과 이동을 위해 팩 파일에는 여러 개체가 포함될 수 있으며 포함된 개체의 SHA-1 해시를 기반으로 하는 파일 이름으로 식별됩니다.

Git은 느슨한 개체를 팩 파일에 자동으로 압축하여 디스크 공간을 절약합니다. , 저장소의 파일 수를 줄이고 전송을 보다 효율적으로 만듭니다. 압축된 개체는 저장 및 전송에 더 효율적이지만 Git에서 액세스할 때 약간의 추가 처리가 필요합니다.

요약하면 두 자리 16진수 폴더와 팩 폴더의 차이점은 전자가 느슨한 파일을 포함한다는 것입니다. 압축되지 않은 개체와 후자에는 효율적인 저장 및 전송을 위해 압축된 압축된 개체가 포함됩니다.

Git은 특정 상황에서 느슨한 개체를 자동으로 팩 파일로 압축하여 저장소의 파일 수를 줄이고 전송을 보다 효율적으로 만듭니다.

기본적으로 Git은 개체 수가 저장소의 느슨한 개체가 구성 변수 `gc.auto`에 의해 결정되는 특정 임계값을 초과합니다. 이 변수의 기본값은 6700이며, 이는 리포지토리에 6700개 이상의 느슨한 개체가 있을 때 Git이 개체를 자동으로 패킹하기 시작함을 의미합니다. 그러나 필요에 따라 이 값을 더 높거나 더 낮은 숫자로 변경할 수 있습니다.

Git은 또한 `git gc` 및 `git과 같은 특정 Git 명령 중에 개체를 압축합니다. 리포지토리의 성능을 최적화하고 디스크 사용량을 줄이는 데 사용되는 repack`입니다.

요약하면 Git은 느슨한 개체 수가 초과하는 경우를 포함하여 특정 조건에서 느슨한 개체를 압축된 개체로 자동으로 압축합니다