# 2진 리프팅

이진 리프팅은 컴퓨터 과학, 특히 알고리즘 설계 및 분석 분야에서 트리 데이터 구조에서 노드의 k번째 조상 또는 최저 공통 조상(LCA)을 찾는 문제를 효율적으로 해결하기 위해 사용되는 기술입니다.

이진 리프팅의 기본 아이디어는 로그 시간에 LCA 쿼리에 응답하는 데 사용할 수 있는 트리에 대한 일부 정보를 미리 계산하고 저장하는 것입니다. 이를 위해 배열 `P`를 구성합니다. 여기서 `P[i][j]`는 노드 `i`의 2^j번째 조상을 나타냅니다. 이 배열은 `P[i][j]`가 `P[P[i][j-1]][j-1]`로 계산되는 동적 프로그래밍을 사용하여 채울 수 있습니다. 이것은 노드 `i`의 2^j번째 조상이 2^(j-1)번째 조상의 2^(j-1)번째 조상임을 의미합니다.

배열 `P`가 구성되면 먼저 문제의 두 노드의 깊이를 결정한 다음 각 노드가 동일한 깊이가 될 때까지 트리 위로 "리프트"하여 LCA 쿼리에 응답할 수 있습니다. 두 노드 사이의 깊이 차이보다 작거나 같은 2의 최대 거듭제곱을 반복적으로 찾고 이를 사용하여 트리를 위로 이동하여 이를 수행합니다.

다음은 트리에서 두 노드 `u` 및 `v`의 LCA를 찾기 위한 이진 리프팅의 예시 구현입니다.

```cpp
int findLCA(int u, int v, int depth[], int P[][MAX_LOG_N]) {
    if (depth[u] < depth[v]) swap(u, v);

    int diff = depth[u] - depth[v];

    for (int i = 0; i < MAX_LOG_N; i++) {
        if ((diff >> i) & 1) {
            u = P[u][i];
        }
    }

    if (u == v) return u;

    for (int i = MAX_LOG_N - 1; i >= 0; i--) {
        if (P[u][i] != P[v][i]) {
            u = P[u][i];
            v = P[v][i];
        }
    }

    return P[u][0];
}

```

이 구현에서 '깊이'는 트리의 각 노드의 깊이를 저장하는 배열이고 'P'는 미리 계산된 조상의 배열입니다. 함수는 먼저 `u`가 최소한 `v`만큼 깊은지 확인한 다음 이진 리프팅을 사용하여 두 노드를 동일한 깊이로 가져옵니다. 그런 다음 최종 이진 검색을 수행하여 LCA를 찾습니다. 이 알고리즘의 시간 복잡도는 'O(log n)'이며, 여기서 'n'은 트리의 노드 수입니다.